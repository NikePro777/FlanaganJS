// код внутри модулей, так же ка и внутри классов автоматически пишется в режиме use strict
// кроме того в модулях нельзя использовать контекст with, arguments и необьявленные переменные
// еще в модулях this даже на верхнем уровне функций возвращает undefined

// 10.3.1 Экспортирование в ES6
// чтобы экспортировать константу, функцию или класс  достаточн добавить перед обьявление ключевое слово export:

class Circle {
  constructor(r) {
    this.r = r;
  }
  area() {
    return PI * this.r * this.r;
  }
}

const pi = 3.14;

// чтобы не спамить словом exports модно просто кучей все экспортировать в конце модуля:
export { Circle, pi }; // причем это не модуль, а просто синтаксис требует список через запятую внутри фигурных скобок

// часто модуль экспортирует только одну функцию, в этом случае пишут export default
// отличие в облегчение работы модулей, экпорт по дефолту может экспортировать и выражения, в том числе анонимные функции или классы
// экспорт по умолчанию модет быть только один, а сами экспорты могут быть только на верхнем уровне ( внутри класса ничего не экспортируем)

// 10.3.2 Импортирование в ES6
// импортируются экспортированные модули с помощью ключевого слова import
import BitSet from "../class/class4";
// import идентификатор from (ключевое слово) строковый литерал - имя модуля который импортируется
// значения которые импортируются это константы
// когда нужно импортировать много файлов из одого:
// import {mean, stdev} from './stats.js'
// оператор import может импортировать любое количство , перечисляя их имена в скобках, все идентификаторы внутри скобок, поднимаются наверх и ведут себя как константы

// импортирование из модуля где много значений может быть таким:
import * as stats from "./stats.js";
// в таком случае оператор import создает обьект и присваевает его константе по имени stats
// юлагодаря этому все функции будут свойствами и к ним можно обращаться stats.mean()

// чтобы подключить модуль без операторов экспорта нужно указать import './analanls.js' без операторов экспорта

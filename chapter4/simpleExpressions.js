// определение функции
let square1 = function (x) {
  return x * x;
};
// Доступ к свойствам
// выражение.идентификатор - для доступа к свойствам обьекта
// выражение [идентификатор] -обьект и массив
let object = { x: 1, y: { z: 3 } };
let massiv = [0, 4, [5, 6]];
console.log(object.x); //1
console.log(object.y.z); //3
console.log(object["x"]); //1
console.log(massiv[1]); //4
console.log(massiv[2]["1"]); //6
// console.log(object[0].x); //

// 4.4.1 Условный доступ к свойствам ?. или ?.[]
// Если свойство есть - переходит по нему, если нет то возвращает undefined (вместо ошибки typeError)

let a; //забыли идентифицировать
let index = 0;
try {
  console.log(a[index++]); // т.к такого свойства нет, генерируется ошибка
} catch (e) {
  console.log(index); // =>1 т.к. инкремент произошел выше
}
console.log(a?.[index++]); // так как свойства индекс нету, то выведет undefined и далее выполняться ничего не будет. если бы ?. не было, вывел бы тайп еррор (как выше)
console.log(index); // =>1 инкремента не было выше
// console.log(a[index++]); // typeError
// 4.5.1 Условный вызов функции.
// Так же с помощью ?. мы можем вернуть undefined вместо typeError при вызове функции. Логика точно такая же: Если функция возвращает null или undefined то генерируется
// typeError. Но с помощью ?. будет генерировать undefined
function square(x, log) {
  if (log) {
    // проверяем ввели ли мы аргумент log при вызове функции
    log(x); // если да то вызываем ее
  }
  return x * x;
} // Теперь можно все это сделать проще:

function square0(x, log) {
  log?.(x); // т.е. если введен логарифм, то вызов пройдет
  return x * x;
} // Однако ?. проверяет только равна ли левая сторона null или undefined.... если будет что то другое (typeError) то один фиг вывалит ошибку: square0(2,3)

let f = null, // именно null а не 0
  x = 0;
try {
  f(x++); // нет такой функции, поэтому ошибка
} catch (e) {
  x; //=1 т.к. инкрементировать смогли
}
f?.(x++); // ничего не будет, так как свойство равно null, было бы 0 то была бы ошибка
console.log(x); //=1 ничего же не сделали выше
// Обзор операций
console.log(~5); //Инвентирование битов... крч меняет знак и вычитает единицу
console.log(delete 5); //  - удаляет свойство
console.log(typeof 3); // в строке пишет тип
console.log(void 5); // возвращает underfined
console.log(2 ** 3); // возведение в степень
console.log(2 << 3); // сдвигает двоичную запись числа 2 на 3 бита влево, добавля нули
console.log(2 >> 3); // вправо, причем при движении начальные стирает
console.log(2 >>> 3); // вправо и заполняет нулями предыдущие цифры
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
const auto = new Car("Honda", "Accord", 1998);
console.log(auto instanceof Car); //Проверяет является ли кар обьектом класса авто => true
console.log(auto instanceof Object);

let obj = { a: 1, b: 2, c: 3 }; //in  проверяет наличие свойства у обьекта
console.log("b" in obj); // выведет true
console.log("x" in obj); // выведет false
console.log(5 | 6); // побитовое или
console.log(5 ^ 2); // побитовое исключающее или // хз нахрена э\то и что это....
console.log(null ?? 1); // выбор первого определенного операнда

// 4.8 Арифметические операции
//  ** - выполняется справо налево, т.е. 2**2**3 === 2**8 а не 4 в 3
console.log(-5 % -2); // остаток от деления имеет знак первого операнда!!!! в данном случае минус
console.log(5 % -2); // в данном случае плюс

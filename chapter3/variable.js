// 3.10.1
// let и const меют блочную видимость. т.е. Они существуют внутри блока, функции в общем между {}
// 3.10.2 var - свойство глобального обьекта globalThis.x = 2 === var x = 2, обладает hoisting'ом (всплатием) т.е. если мы обьявим внутри функции,
// будет видна глобально, однако не инициализирована
// Диструктурирующее присваивание
let [x, y] = [1, 2]; // x=1, y=2
console.log([x, y]);
[x, y] = [x + 1, y + 1]; //x=x+1, y=y+1
console.log([x, y]);
[x, y] = [y, x]; // поменяли местами
console.log([x, y]);
// Облегчает работу с функциями, которые возвращают массивы
function toPolar(x, y) {
  // Преобразует обычные координаты в полярные
  return [Math.sqrt(x * x + y * y), Math.atan2(y, x)]; // угол с учетом пи показывает
}

function toCartesian(r, theta) {
  // Преобразует полярные координаты в обычные
  return [r * Math.cos(theta), r * Math.sin(theta)];
}

let [r, theta] = toPolar(1.0, 1.0); // r == Math.sqrt(2); theta == Math.PI/4
console.log(r, theta);
console.log(([x, y] = toCartesian(r, theta))); // [x, y] == [1.0, 1,0]

// Присваивание будет в отдельной итерации цикла:
let o = { x: 1, y: 2 };
for (const [name, value] of Object.entries(o)) {
  console.log(name, value);
}

// Количество переменных слева и справа при деструктуризировании не обязательно должно совпадать
let [q, w] = [1]; // q=1,w=undefined
console.log([q, w]); // т.е недостающие обьявляются undefined
[q, w] = [1, 2, 3]; //q=1,w=2
console.log([q, w]); // лишние игнорируются
[, q, , w] = [1, 2, 3, 4]; //q=2, w=4
console.log([q, w]); // можно пропускать
// Все оставшиеся значения можно уложить в одну переменную!!!! Они собираются в одиночный массив
[q, ...w] = [1, 2, 3, 4];
console.log(q, w); // w=[2,3,4]

// Присваивание можно делать и со вложенными массивами, главное чтобы левая часть совпадала:
let [a, [b, c]] = [1, [3, 5], 7];
console.log(a, b, c); //1 3 5
// Массив НЕ обязателен!!!
let [e, ...t] = "Привет";
console.log(e, t); // e=> 'П' t=>['р', 'и', 'в', 'е', 'т']

// Деструктурирование обьектов
let transparent = { g: 1, s: 2, d: 3, f: 4 };
let { g, s, d } = transparent; // тут главное чтобы эти переменные были ключами в данном обьекте, иначе undefined
console.log(g, s, d); // 1 2 3

// Для глобальных обьектов тоже работает:
const { sin, cos, tan } = Math;
// тоже самое что и sin=Math.sin и т.д.

// имена не обязательно должны совпадать, но тогда внутри пишется два значения - значение переменной которая есть в обьекте и через двоеточие название этой переменной
// т.е. имя свойства которое присваивается : имя переменной
const { cos: cosine, sin: sinine } = Math; //cosine=Math.cos sinine=Math.sin

// Деструктуризация с вложенными обьектами и массивами сложна, но законна....
let points = [
  { x: 1, y: 2 },
  { x: 3, y: 4 },
];
let [{ x: x1, y: y1 }, { x: x2, y: y2 }] = points;
console.log(x1, y1, x2, y2); //1,2,3,4

let points2 = { p1: [5, 6], p2: [7, 8] };
let {
  p1: [xx1, yy1],
  p2: [xx2, yy2],
} = points2;
console.log(xx1, yy1, xx2, yy2); //5,6,7,8
// Крч намного проще let x1=points.p1[0]

//7.1.1 Создание массивов с помощью литерала []
let count = [1, , 2]; // длина равна 3, но второго элемента нет. Такой массив разряженный
// 7.1.2 Операция распространения ...
// Позволяет создать (неглубокую) копию массива, который не изменит оригинал
let a = [1, 2, 3];
let b = [2, 3, ...a, 4];
console.log(b); //[2, 3, 1, 2, 3, 4]
// ... работает с любым итерируемым обьектом (те для которых применяется цикл for/of)
let digits = [..."0123asd"];
console.log(digits); //['0', '1', '2', '3', 'a', 's', 'd']
// обьекты множества Set итерируемы, так что если надо избавиться от дубликатов:
let letter = [..."helllo   woooorldd"];
console.log(...new Set(letter)); //h e l o   w r d
// 7.1.3 Конструктор Array , можно вызвать 3 способами
let c = Array(); // ~[]
let d = Array(10); // создает массив длиной 10 , ячейки заполняются [empty × 10] , каждая из них undefined
let f = Array(5, 4, 3, 2, 1, "test,test");
console.log(f);
// 7.1.5 Array.from()
let copy = Array.from(f); // тоже самое что copy=[...f]
// НО!! у Array.from есть необязательный второй аргумент - функция. И КАЖДЫЙ эл-т массива будет передан этой функции (типа map но при создании)
let copy2 = Array.from(copy, (a) => {
  return a * 2;
});
console.log(copy); // [5, 4, 3, 2, 1, 'test,test']
console.log(copy2); // [10, 8, 6, 4, 2, NaN]

// 7.2 Чтение и запись элементов массива
a = ["world"];
i = 2;
a[i] = 3;
a[i + 1] = "hello";
a[a[i]] = a[0];
console.log(a); // В общем особенность в том что длина изменяется каждый раз когда мы новое свойство добавляем
// к обьекту мы можем обращаться так же как и к массиву [1] потому что 1 => '1' и это будет именем свойства
// но если такой строки нет, то создастсся новое свойство с таким именем:
o = {};
o[1.05] = "123"; // {1.05: "123"}

// 7.3 Разреженный массив
// Это тот у которого есть пустая ячейка, получить их можно удалив значение или
a = Array(5); // Создаст массив с 5 пустыми ячейками, т.е. длина равна 5 а значений нету
a[100] = 1; // Сотый элемент стал равен 1 соответственно длина стала тоже 101 равна... вот только ячейка всего одна в нем
console.log(a);
let a1 = [,]; // Запятая в конце массива - это норм. т.е. элемент будет только один, вернее его вообще не будет а длина равна 1
let a2 = [undefined]; // Это элемент со значением undefined
console.log(0 in a1); //false
console.log(0 in a2); // true
console.log(a1); //[empty]
console.log(a2); //[undefined]
// 7.4 Длина массива
a = [];
console.log(a.length);
console.log((a = ["a", "s", "d"])); // длина массива равна 3 , индекс самого большого элемента равен 2
// Крч длина тоже устанавливается! и тут два свойства:
a.length = 1; // Если длиина которую мы установили меньше чем которая по факту
console.log(a); //['a'] - Все элементы индекс которых был выше чем длина - удаляются
a.length = 10; // если мы установили длину больше - все элементы заполнятся пустыми значениями
console.log(a); // ['a', empty × 9]
// 7.5 Добавление и удаление элементов массива
a = [];
a.push(34, 5); // push для добавления в конец массива одного или нескольких элементов ~ a[length]=...
console.log(a);
a.unshift("sad", "sdfsf"); // Для добавления элементов в начало массива (со сдвигом всех остальных вправо)
console.log(a);
a.pop(2); // Удаляет последний элемент (противоположно push)
a.shift(2); // Удаляет первый (противоположно unshift)
console.log(a);
// ну и delete которые не сдвигает остальные элементы а просто оставляет пустую ячейку (undefined)
delete a[0]; // индекс обязателен
console.log(a); //[empty, 34]

// 7.6 Интерация по массивам
// for/of самое простое
let letters = [..."Hello world"];
let string = [];
for (let letter of letters) {
  string += letter;
}
console.log(string); // Hello world - переписали строку. Все пустые элементы массива, такой цикл вернет как undefined

let everyother = "";
for (let [index, letter] of letters.entries()) {
  // entries - пара ключ, значение
  if (index % 2 === 0) {
    everyother += letter;
  }
}
console.log(everyother); // Hlowrd -только четные буквы
// forEach() - передаем в качестве аргумента функцию, и foreach будет вызывать ее для каждого элемента
let uppercase = [];
letters.forEach((letter) => {
  uppercase += letter.toUpperCase();
});
console.log(uppercase); //HELLO WORLD В отличие от for/of не будет проходится по несуществующим элементам
// for
let vowels = "";
for (let i = 0; i < letters.length; i++) {
  let letter = letters[i];
  if (/[aeiou]/.test(letter)) {
    //Проверяем на наличие символов согласно регулярному выражению
    vowels += letter; // если есть то добавляем их
  }
}
console.log(vowels);
// Чтобы увеличить производительность (хз насколько) длину делают постоянной:
// for (let i = 0; let = letters.length, i<let; i++)
// for (let i = letters.length-1; i>0; i--) - Перебор массива в обратном направлении
// Однако в этом случае нужно проверять значения массива на неопределенные:
for (let i = 0; (let = letters.length), i < let; i++) {
  if (a[i] === undefined) continue;
  {
    /*тело цикла*/
  }
}

// 7.7 Многомерные массивы
// Если есть массив, каждый элемент которого тоже массив, то для обращения к элементу надо: matrix[x][y]
let table = new Array(10); // 10 строк таблицы
for (i = 0; i < table.length; i++) {
  table[i] = new Array(10); // Каждая строка имеет 10 столбцов
}
for (let row = 0; row < table.length; row++) {
  // для каждого столба
  for (let col = 0; col < table[row].length; col++) {
    // каждой строчки в столбце
    table[row][col] = row * col; // делаем перемножение
  }
}
console.log(table[5][7]); // 35 получили таблицу умножения

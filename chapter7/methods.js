// 7.8 Методы массивов
// Все методы принимают функцию в своем аргументе (обычно стрелочную), которая применяется для каждого элемента массива (пропуская undefined)
// функция же может принимать 3 аргумента: Значение элемента; индекс элемента; массив (2 и 3 необязательны)

// for Each()
let data = [1, 2, 3, 4, 5],
  sum = 0;
data.forEach((value) => {
  // вычисляем сумму элементов массива
  sum += value;
});
console.log(sum); //15
// а теперь инкрементируем каждый элемент массива
data.forEach(function (v, i, a) {
  a[i] = v + 1;
});
console.log(data); // [2, 3, 4, 5, 6]

// map - тоже самое что forEach но только все элементы возвращаются в новый массив. Поэтому функция должна что то возвращать

a = [1, 2, , 3];
console.log(a.map((x) => x * x)); //[1, 4, empty, 9] при этом исходный массив - неизменный

// filter() если элемент удовлетворяет условиям функции - он возратится
// функция предикат - функция возвращающая true или false

a = [1, 2, 3, 4, 5];
console.log(a.filter((x) => x < 3)); // [1, 2]
console.log(a.filter((x, i) => i % 2 === 0)); // [1, 3, 5]
let sparse = [, , , undefined, null, 0, 2, 4];
let dance = sparse.filter(() => true); // чтобы убрать бреши в массиве
console.log(dance); // [undefined, null, 0, 2, 4]
let dance2 = sparse.filter((x) => x !== undefined && x !== null); // чтобы убрать бреши в массиве и удалить пустые и неизвестные элементы
console.log(dance2); // [0, 2, 4]

// find() и findIndex() - как и фильтер - ищут элементы, которые подходят по условию, но как только находят - заканчивают перебор всего. find возвращает элемент
// а findIndex возвращает индекс. Если не находят то find возвращает undefined, а findIndex возвращает -1

a = [1, 2, 3, 4, 5];
console.log(a.findIndex((x) => x === 3)); // 2
console.log(a.findIndex((x) => x < 0)); // -1
console.log(a.find((x) => x % 5 === 0)); // 5
console.log(a.find((x) => x % 7 === 0)); // undefined (числа кратные 7 в массиве отсутствуют)

// every() и some() - предикаты массивов - пременяют к вашим элементам указанную функцию и возвращают true или false

// every - ~'для всех' - вернет true только если ВСЕ элементы удовлетворяют условию
a = [1, 2, 3, 4, 5];
console.log(a.every((x) => x % 2 === 0)); // false
console.log(a.every((x) => x < 10)); // true
// some - наоборот, если хотя бы один элемент удовлетворит - true, иначе false
console.log(a.some((x) => x % 2 === 0)); // true - содержит несколько четных
console.log(a.some(isNaN)); // false - не содержит "не числа"
// тут как в кз - как только ясно что вернем true или false - остальные элементы не проверяем
let s = [];
// Кроме того на пустом массиве принято:
console.log(s.some((x) => x)); // false
console.log(s.every((x) => x)); // true

// reduse() и reduseRigth() - обьединяют элементы массива для получения единственного значения
a = [1, 2, 3, 4, 5];
console.log(a.reduce((x, y) => x + y, 0));
console.log(a.reduce((x, y) => x * y, 1));
console.log(a.reduce((x, y) => (x > y ? x : y)));
// reduce принимает 2 аргумента. 1ый это функция, которая должна как то сократить
// два значения в одно и возвратить его. второй аргумент (необязательный) начальное значение, для передачи в функции
// Cама же функция reduce принимает не 3 (как forEach,map) а 4 аргумента. Элемент, индекс и массив, становятся 2,3 и 4 аргументами.
// а первый - это накопленный до сих пор результат сокращения. Крч начальное значение нашего аккумулятора
// Если начального значения не будет, или массив будет пустым - то reduce просто возвратит его, не вызывая функцию сокращения

let seniorJS = [NaN, null, undefined, false];
let seniorResult = seniorJS.reduce(function (b, c) {
  console.log(b); // Это индекс массива получается
  console.log(c); // элемент массива
  console.log(
    `Cумма на данный момент   ${b + seniorJS.findIndex((d) => d === c)}`
  );
  return b + seniorJS.findIndex((d) => d === c); // тут мы ищем элемент который равен с, т..е текущему элементу
}, 0);

console.log("seniorResult= " + seniorResult);
// reduseRigth() - тоже самое, но операцию делает справа налево, т.е. от самого высокого индекса к нулевому
// например 2^(3^4)  в данном случае нам надо возводить справо налево:
a = [2, 3, 4];
console.log(a.reduceRight((acc, val) => Math.pow(val, acc))); // 2.4178516392292583e+24

// 7.8.2 Выравнивание массивов с помощью flat() и flatMap()
// flat() создает и возвращает новый массив, содержащий те же самые элементы, но при этом вложенные в первоначальный массив
// массивы будут "выровнены"
console.log([1, [2, 3]].flat()); //[1, 2, 3]
console.log([1, [2, [3]]].flat()); // [1, 2, Array(1)] === [1, 2,[3]]
// в качестве аргумента принимает количество уровней, на которое надо выравнять (крч сколько раз повторить)
console.log([1, [2, [3]]].flat(2)); // [1, 2, 3]

// flatMap() тоже самое что мэп, но только предварительно выравненный. Дает возможность отобразить входные элементы на пустой массив, который ничего не выравнивает:
console.log([-2, -1, 1, 2].flatMap((x) => (x < 0 ? [] : Math.sqrt(x)))); // [1, 1.4142135623730951]

// 7.8.3 Присоединение массивов с помощью concat()
// concat присоединяет текущий массив к массиву/вам которые приняты в аргументе И выравнивает их на один уровень.
//(элемент или массив с элементами будут следующими элементами исходного массива). Текущий массив НЕ трогает!
a = [1, 2, 3];
console.log(a.concat(4, 5)); //[1, 2, 3, 4, 5]
console.log(a.concat([4, 5], [6, 7])); //[1, 2, 3, 4, 5, 6, 7]
console.log(a.concat(4, [5, [6, 7]])); //[1, 2, 3, 4, 5, Array(2)] === [1, 2, 3, 4, 5,[6, 7]]
console.log(a); // [1, 2, 3] - не изменил текущий массив

// 7.8.4 Организация стеков и очередей с помощью push(), pop(), shift(), unshift()
// push добавляет элемнт в конец массива и возвращает длину установившуюся
// pop убирает последнее значение из массива и возвращает его
let stack = []; // реализация стека
console.log(stack.push(1, 2)); // вернет 2, так как длина массива 2 [1,2]
console.log(stack.pop()); // вернет 2 так как убранный элемент 2
console.log(stack.push(3));
console.log(stack.pop());
console.log(stack.push([4, 5])); //  push не выравнивает массив!!! [1,[4,5]]
console.log(stack.pop()); // вернет [4,5]
console.log(stack.pop()); // вернет 1
//  чтобы добавить элементы и выровнить их можно воспользоваться оператором распространения ...
let add = [3, 4, [5, 6]];
console.log(stack.push(...add));
console.log(stack);
//с функцией шифта можно реализовать очередь
let q = [];
console.log(q.push(1, 2));
console.log(q.shift()); // вернет 1 , так как удалил элемент равный 1
console.log(q.push(3));
console.log(q.shift());
console.log(q.shift());
// особенность unshift в том, что если мы в качестве аргумента передадим несколько, они встанут сразу...
a = [];
a.unshift(1);
a.unshift(2); // a=[2,1]
a = [];
a.unshift(1, 2);
console.log(a); // [1, 2]

// 7.8.5 Работа с подмассивами с помощью slice(), splice(), fill(), и copyWithin()
// slice() срезает с первого аргумента и до второго ( или до конца массива если не задан второй)  и возвращает. Если число отрицательное - считает с конца
a = [1, 2, 3, 4, 5];
console.log(a.slice(0, 3)); //[1, 2, 3]
console.log(a.slice(3)); //[4, 5]
console.log(a.slice(1, -1)); // [2, 3, 4]
console.log(a.slice(-3, -2)); // [3]

// splice ()
// - Модифицирует исходный массив!!! аргументы бесконечны. Первый - с какого элемента обрезать. Второй - Сколько обрезать (длина)
a = [1, 2, 3, 4, 5, 6, 7, 8];
console.log(a.splice(4)); // вернет [5, 6, 7, 8] при этом a=[1,2,3,4]
console.log(a.splice(1, 2)); // [2, 3] вернет (их же удалит с массива) а=[1,4]
console.log(a.splice(1, 1)); // 4 - удалит, останется 1
console.log(a); //[1]
// остальные аргументы будут вставлены в исходный массив начиная с индекса, который указывался первым
a = [1, 2, 3, 4, 5];
console.log(a.splice(2, 0, "a", "b")); // со сторого индекса удалить 0 элементов, вставить на второй и последующий индексы 'a','b'
console.log(a); // [1, 2, 'a', 'b', 3, 4, 5]
console.log(a.splice(2, 2, [1, 2], 3)); // - начиная со второго индекса удалить 2 элемента, начиная со второго индекса вставить следующие элементы: [1,2],3
console.log(a); //[1, 2, Array(2), 3, 3, 4, 5] - в отличие от concat не модифицирует массивы. (вставляет массивы а не элементы)

// fill()
// Изменяет указанный массив данными значениями. 3 аргумента: 1. какием элементом будем заполнять массив. 2 - индекс с какого начнем заполнять
// 3 - до какого будем заполнять. как и slice может работать с отрицательными числами
a = new Array(5);
console.log(a.fill(5)); //[5, 5, 5, 5, 5]
console.log(a.fill(9, 1)); //[5, 9, 9, 9, 9] т.е. заменили на 9 все элементы начиная с первого
console.log(a.fill(8, 2, -1)); // заменяем на 8 все элементы начиная со 2 и по -1 (в нашем случае 3) [5, 9, 8, 8, 9]

// copyWithin()
// Копирует срез массива в новую позицию внутри массива. Модифицирует исходный массив, оставляя неизменным длину. 3 аргумента:
// 1.- с какого элемента вставлять. 2. с какого элемента копировать. 3. по какой элемент копировать
a = [1, 2, 3, 4, 5];
console.log(a.copyWithin(1)); // вставить начиная с первого элемента индексы от начала массива и до конца // [1, 1, 2, 3, 4]
console.log(a.copyWithin(2, 3, 5)); // вставить с третьего по 5ый элемент начиная со второго // [1, 1, 3, 4, 4]
console.log(a.copyWithin(0, -2)); // вставить с начала массива элементы начиная с предпоследнего // [4, 4, 3, 4, 4]

// Методы поиска и сортировки массивов
// indexOf() и lastIndexOf()
// Ищут значение аргумента в массиве, и возврашают его индекс если находят, или -1
// indexOf ищет слева направо, lastIndexOf - с конца
a = [0, 1, 2, 1, 0];
console.log(a.indexOf(1)); // 1
console.log(a.lastIndexOf(1)); // 3
console.log(a.indexOf(3)); // -1 так как нет такого
// есть еще необязательный второй аргумент - индекс с которого надо начинать поиск(м.б. отрицательным)
// Ишет все значения х в массиве, и возвращает массив с совпадающими индексами

function findall(a, x) {
  let results = [], // The array of indexes we'll return
    len = a.length, // The length of the array to be searched
    pos = 0; // The position to search from
  while (pos < len) {
    // Пока есть элементы для поиска
    pos = a.indexOf(x, pos); // Ищем
    if (pos === -1) break; // Если ничего не найдено - выходим
    results.push(pos); // иначе сохраняем индекс в массиве
    pos = pos + 1; // And start next search at next element
  }
  return results; // Return array of indexes
}

// includes()
// Если указанный в аргументе элемент есть в массиве- вернет true, иначе false
//  в отличие от indexOf имеет немного другой алгоритм- позваоляет находить NaN:
a = [1, true, NaN, 3];
console.log(a.includes(true)); // true
console.log(a.includes(2)); //false
console.log(a.includes(NaN)); //true
console.log(a.indexOf(NaN)); //-1

// sort() сортирует массив.
// если без аргументов, то все преобразовывает в строку и сортирует в алфавитном порядке:
a = ["banana", "cherry", "apple"];
console.log(a.sort()); //['apple', 'banana', 'cherry']
// Если нам нужно сравнить числа, то мы должны передать функцию, и далее эта функция
// должна вернуть отрицательное число, если первый аргумент должен находится перед вторым,
// и положительное, если второй аргумент должен быть впереди

a = [33, 4, 1111, 222];
console.log(a.sort()); // [1111, 222, 33, 4] т.к. 1 в алфавитном порядке меньше 2 и т.д.
console.log(
  a.sort(function (a, b) {
    return a - b;
  })
); // [4, 33, 222, 1111]
console.log(a.sort((a, b) => b - a)); //[1111, 222, 33, 4]
// Сортировка в алфовитном порядке чувствительна к регистру, поэтому иногда надо привести к одному регистру:
a = ["ant", "Bug", "cat", "Dog"];
console.log(a.sort()); // ['Bug', 'Dog', 'ant', 'cat'] т.к. регистр решает
// исправляем:
console.log(
  a.sort(function (q, w) {
    a = q.toLowerCase();
    b = w.toLowerCase();
    if (a > b) {
      return 1;
    }
    if (a < b) {
      return -1;
    }
    return 0;
  })
); // ['ant', 'Bug', 'cat', 'Dog'] теперь нечувствительна к регистру

// reverse() - изменяет на противоположный порядок следования элементов в массиве
a = [1, 2, 3];
console.log(a.reverse()); //[3, 2, 1]

// Преобразование массивов в строки
// Если нужно сохранить данные в тексте то достаточно сериализовать с помощью JSON.stringify()
// join() - преобразует все элементы массива в строки и выполняет их конкатенацию, возвращая общую строку. В качестве аргумента можно указать эл-т строки, который будет разделителем
a = [1, 2, 3];
console.log(a.join()); // по умолчанию там запятая 1,2,3
console.log(a.join(" ")); //1 2 3
console.log(a.join("")); //123
b = new Array(10);
console.log(b.join("-")); // --------- девять дефисов
// toString работает как  join без аргументов (т.е. будут запятые)
console.log([1, 2, 3].toString()); //1,2,3
console.log([1, [2, "c"]].toString()); //1,2,c любые ограничители не влючаются в вывод, поэтому []нет

// 7.8.8 Статические функции массивов
// Кроме Array.of и Array.from() (7.1.4-5) есть еще isArray() - который опрееляет, является ли аргумент массивом или нет
console.log(Array.isArray([])); // true
console.log(Array.isArray({})); // false

// 7.9 Обьекты похожие на массивы
// Если пустой обьект не менять (использовать только для чтения) или хотя бы не менять его длину, то можно обращаться с ним как с массивом:
a = {};
let i = 0;
while (i < 10) {
  a[i] = i * i;
  i++;
}
console.log((a.length = i)); // 10
let total = 0;
for (let j = 0; j < a.length; j++) {
  total += a[j];
}
console.log(total); // 285
console.log(a); // {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81, length: 10}

// На стороне клиента некоторые методы возвращают обьекты, похожие на массивы (document.querySelectorAll()), ниже функция, показывающая, работают ли они как массивы:
function isArrayLike(o) {
  if (
    o && // Проверяем что обьект не равен null,undefined и т.д.
    typeof o === "object" && // если он обьект и
    Number.isFinite(o.length) && // длина волны конечна
    o.length >= 0 && // положительна
    Number.isInteger(o.length) && // равна целому числу
    o.length < 4294967295
  ) {
    // и меньше  < 2^32 - 1
    return true; // тогда обьект похож на массив
  } else {
    return false; // иначе нет)
  }
}
// обьекты похожие на массивы не являются протитипами Array, поэтому методы массивов для них не работают, однако можно вызвать их косвенно с помощью call:
a = { 0: "a", 1: "b", 2: "c", length: 3 }; // Обьект похожий на массив
console.log(Array.prototype.join.call(a, "+")); // a+b+c
console.log(Array.prototype.map.call(a, (x) => x.toUpperCase())); // ['A', 'B', 'C']
console.log(Array.prototype.slice.call(a, 0)); // ['a', 'b', 'c'] - копирование в подлинный массив
console.log((b = Array.from(a))); // ['a', 'b', 'c'] - более легкое копирование
console.log(b);

// 7.10 Строки как массивы
// Если массив используется только для чтения в кодировке UTF-16 то вместо charAt можно использовать []
s = "test";
console.log(s.charAt(1)); //e
console.log(s[1]); //e
// typeof по прежнему вернет string.
// Для операций которые не модифицируют строку, мы так же можем применять методы массивов:
console.log(Array.prototype.join.call(s, " ")); // t e s t
// раз строка неизменяема то методы sort, reverse и другие - не работают. однако и ОШИБКИ НЕ БУДЕТ. просто молча неудача

// 7.8 Методы массивов
// Все методы принимают функцию в своем аргументе (обычно стрелочную), которая применяется для каждого элемента массива (пропуская undefined)
// функция же может принимать 3 аргумента: Значение элемента; индекс элемента; массив (2 и 3 необязательны)

// for Each()
let data = [1, 2, 3, 4, 5],
  sum = 0;
data.forEach((value) => {
  // вычисляем сумму элементов массива
  sum += value;
});
console.log(sum); //15
// а теперь инкрементируем каждый элемент массива
data.forEach(function (v, i, a) {
  a[i] = v + 1;
});
console.log(data); // [2, 3, 4, 5, 6]

// map - тоже самое что forEach но только все элементы возвращаются в новый массив. Поэтому функция должна что то возвращать

a = [1, 2, , 3];
console.log(a.map((x) => x * x)); //[1, 4, empty, 9] при этом исходный массив - неизменный

// filter() если элемент удовлетворяет условиям функции - он возратится
// функция предикат - функция возвращающая true или false

a = [1, 2, 3, 4, 5];
console.log(a.filter((x) => x < 3)); // [1, 2]
console.log(a.filter((x, i) => i % 2 === 0)); // [1, 3, 5]
let sparse = [, , , undefined, null, 0, 2, 4];
let dance = sparse.filter(() => true); // чтобы убрать бреши в массиве
console.log(dance); // [undefined, null, 0, 2, 4]
let dance2 = sparse.filter((x) => x !== undefined && x !== null); // чтобы убрать бреши в массиве и удалить пустые и неизвестные элементы
console.log(dance2); // [0, 2, 4]

// find() и findIndex() - как и фильтер - ищут элементы, которые подходят по условию, но как только находят - заканчивают перебор всего. find возвращает элемент
// а findIndex возвращает индекс. Если не находят то find возвращает undefined, а findIndex возвращает -1

a = [1, 2, 3, 4, 5];
console.log(a.findIndex((x) => x === 3)); // 2
console.log(a.findIndex((x) => x < 0)); // -1
console.log(a.find((x) => x % 5 === 0)); // 5
console.log(a.find((x) => x % 7 === 0)); // undefined (числа кратные 7 в массиве отсутствуют)

// every() и some() - предикаты массивов - пременяют к вашим элементам указанную функцию и возвращают true или false

// every - ~'для всех' - вернет true только если ВСЕ элементы удовлетворяют условию
a = [1, 2, 3, 4, 5];
console.log(a.every((x) => x % 2 === 0)); // false
console.log(a.every((x) => x < 10)); // true
// some - наоборот, если хотя бы один элемент удовлетворит - true, иначе false
console.log(a.some((x) => x % 2 === 0)); // true - содержит несколько четных
console.log(a.some(isNaN)); // false - не содержит "не числа"
// тут как в кз - как только ясно что вернем true или false - остальные элементы не проверяем
let s = [];
// Кроме того на пустом массиве принято:
console.log(s.some((x) => x)); // false
console.log(s.every((x) => x)); // true

// reduse() и reduseRigth() - обьединяют элементы массива для получения единственного значения
a = [1, 2, 3, 4, 5];
console.log(a.reduce((x, y) => x + y, 0));
console.log(a.reduce((x, y) => x * y, 1));
console.log(a.reduce((x, y) => (x > y ? x : y)));
// reduce принимает 2 аргумента. 1ый это функция, которая должна как то сократить
// два значения в одно и возвратить его. второй аргумент (необязательный) начальное значение, для передачи в функции
// Cама же функция reduce принимает не 3 (как forEach,map) а 4 аргумента. Элемент, индекс и массив, становятся 2,3 и 4 аргументами.
// а первый - это накопленный до сих пор результат сокращения. Крч начальное значение нашего аккумулятора
// Если начального значения не будет, или массив будет пустым - то reduce просто возвратит его, не вызывая функцию сокращения

// reduseRigth() - тоже самое, но операцию делает справа налево, т.е. от самого высокого индекса к нулевому
// например 2^(3^4)  в данном случае нам надо возводить справо налево:
a = [2, 3, 4];
console.log(a.reduceRight((acc, val) => Math.pow(val, acc))); // 2.4178516392292583e+24

// 7.8.2 Выравнивание массивов с помощью flat() и flatMap()
// flat() создает и возвращает новый массив, содержащий те же самые элементы, но при этом вложенные в первоначальный массив
// массивы будут "выровнены"
console.log([1, [2, 3]].flat()); //[1, 2, 3]
console.log([1, [2, [3]]].flat()); // [1, 2, Array(1)] === [1, 2,[3]]
// в качестве аргумента принимает количество уровней, на которое надо выравнять (крч сколько раз повторить)
console.log([1, [2, [3]]].flat(2)); // [1, 2, 3]

// flatMap() тоже самое что мэп, но только предварительно выравненный. Дает возможность отобразить входные элементы на пустой массив, который ничего не выравнивает:
console.log([-2, -1, 1, 2].flatMap((x) => (x < 0 ? [] : Math.sqrt(x)))); // [1, 1.4142135623730951]

// 7.8.3 Присоединение массивов с помощью concat()
// concat присоединяет текущий массив к массиву/вам которые приняты в аргументе И выравнивает их на один уровень.
//(элемент или массив с элементами будут следующими элементами исходного массива). Текущий массив НЕ трогает!
a = [1, 2, 3];
console.log(a.concat(4, 5)); //[1, 2, 3, 4, 5]
console.log(a.concat([4, 5], [6, 7])); //[1, 2, 3, 4, 5, 6, 7]
console.log(a.concat(4, [5, [6, 7]])); //[1, 2, 3, 4, 5, Array(2)] === [1, 2, 3, 4, 5,[6, 7]]
console.log(a); // [1, 2, 3] - не изменил текущий массив

// 7.8.4 Организация стеков и очередей с помощью push(), pop(), shift(), unshift()
// push добавляет элемнт в конец массива и возвращает длину установившуюся
// pop убирает последнее значение из массива и возвращает его
let stack = []; // реализация стека
console.log(stack.push(1, 2)); // вернет 2, так как длина массива 2 [1,2]
console.log(stack.pop()); // вернет 2 так как убранный элемент 2
console.log(stack.push(3));
console.log(stack.pop());
console.log(stack.push([4, 5])); //  push не выравнивает массив!!! [1,[4,5]]
console.log(stack.pop()); // вернет [4,5]
console.log(stack.pop()); // вернет 1
//  чтобы добавить элементы и выровнить их можно воспользоваться оператором распространения ...
let add = [3, 4, [5, 6]];
console.log(stack.push(...add));
console.log(stack);
//с функцией шифта можно реализовать очередь
let q = [];
console.log(q.push(1, 2));
console.log(q.shift()); // вернет 1 , так как удалил элемент равный 1
console.log(q.push(3));
console.log(q.shift());
console.log(q.shift());
// особенность unshift в том, что если мы в качестве аргумента передадим несколько, они встанут сразу...
a = [];
a.unshift(1);
a.unshift(2); // a=[2,1]
a = [];
a.unshift(1, 2);
console.log(a); // [1, 2]

// 7.8.5 Работа с подмассивами с помощью slice(), splice(), fill(), и copyWithin()
// slice() срезает с первого аргумента и до второго ( или до конца массива если не задан второй)  и возвращает. Если число отрицательное - считает с конца
a = [1, 2, 3, 4, 5];
console.log(a.slice(0, 3)); //[1, 2, 3]
console.log(a.slice(3)); //[4, 5]
console.log(a.slice(1, -1)); // [2, 3, 4]
console.log(a.slice(-3, -2)); // [3]

// splice ()
// - Модифицирует исходный массив!!! аргументы бесконечны. Первый - с какого элемента обрезать. Второй - Сколько обрезать (длина)
a = [1, 2, 3, 4, 5, 6, 7, 8];
console.log(a.splice(4)); // вернет [5, 6, 7, 8] при этом a=[1,2,3,4]
console.log(a.splice(1, 2)); // [2, 3] вернет (их же удалит с массива) а=[1,4]
console.log(a.splice(1, 1)); // 4 - удалит, останется 1
console.log(a); //[1]
// остальные аргументы будут вставлены в исходный массив начиная с индекса, который указывался первым
a = [1, 2, 3, 4, 5];
console.log(a.splice(2, 0, "a", "b")); // со сторого индекса удалить 0 элементов, вставить на второй и последующий индексы 'a','b'
console.log(a); // [1, 2, 'a', 'b', 3, 4, 5]
console.log(a.splice(2, 2, [1, 2], 3)); // - начиная со второго индекса удалить 2 элемента, начиная со второго индекса вставить следующие элементы: [1,2],3
console.log(a); //[1, 2, Array(2), 3, 3, 4, 5] - в отличие от concat не модифицирует массивы. (вставляет массивы а не элементы)

// fill()
// Изменяет указанный массив данными значениями. 3 аргумента: 1. какием элементом будем заполнять массив. 2 - индекс с какого начнем заполнять
// 3 - до какого будем заполнять. как и slice может работать с отрицательными числами
a = new Array(5);
console.log(a.fill(5)); //[5, 5, 5, 5, 5]
console.log(a.fill(9, 1)); //[5, 9, 9, 9, 9] т.е. заменили на 9 все элементы начиная с первого
console.log(a.fill(8, 2, -1)); // заменяем на 8 все элементы начиная со 2 и по -1 (в нашем случае 3) [5, 9, 8, 8, 9]

// copyWithin()
// Копирует срез массива в новую позицию внутри массива. Модифицирует исходный массив, оставляя неизменным длину. 3 аргумента:
// 1.- с какого элемента вставлять. 2. с какого элемента копировать. 3. по какой элемент копировать
a = [1, 2, 3, 4, 5];
console.log(a.copyWithin(1)); // вставить начиная с первого элемента индексы от начала массива и до конца // [1, 1, 2, 3, 4]
console.log(a.copyWithin(2, 3, 5)); // вставить с третьего по 5ый элемент начиная со второго // [1, 1, 3, 4, 4]
console.log(a.copyWithin(0, -2)); // вставить с начала массива элементы начиная с предпоследнего // [4, 4, 3, 4, 4]

// Методы поиска и сортировки массивов

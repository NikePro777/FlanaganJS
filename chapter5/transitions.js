// 5.5 Переходы (Операторы) - заставить, что бы что -то произошло
// 5.5.1 Помеченные операторы
// идентификатор: оператор
// В общем можно дать имя любому оператору, и затем вызывать его внутри тела
let token;
//* mainloop: while (token !== null) {
//   // что то делать
//   continue mainloop; // перейти к след итерации
//   // какой то код *
// }

// 5.5.2 break
// Если используется в одиночку, то немедленно выходит из внутреннего цикла или switch
// вообще нужен если нет необходимости продолжать цикл:
// for (let i = 0; i < a.length; i++) {
//   if ((a[i] = target)) break;
// }

// Если break используется вместе с меткой, то он завершит тот цикл, чей меткой является (!!! главное чтобы между именем и break не было перехода строки)

// Например надо посчитать  все числа в матрице (двумерном масстве)
// let matrix = getData(); // Берем откуда нить двумерный массив
let matrix = [[1], [2], [3]];
let sum = 0,
  success = false;

computeSum: if (matrix) {
  for (let x = 0; x < matrix.length; x++) {
    let row = matrix[x];
    if (!row) break computeSum;
    for (let y = 0; y < row.length; y++) {
      let cell = row[y];
      if (isNaN(cell)) break computeSum;
      sum += cell;
    }
  }
  success = true;
} // вот сюда выйдут операторы break
// Ну и соответственно если мы пришли сюда с success = false значит какая то фигня с матрицей
console.log(sum);
console.log(success);

// 5.3.3 continue
// синтаксис и метки аналогично break, только continue перезапускает цикл со СЛЕДУЮЩЕЙ итерацией (эта заканчивается)
// в разных видах выполняется по разному, но основное:
// в циклах for сначаа инкрементируется значение, а затем проиходит проверка и если все ок итерация
// а в циклах while сразу переходит к условию
let data = [1, 2, undefined, 4],
  total = 0;
for (let i = 0; i < data.length; i++) {
  if (!data[i]) continue; // Если данные не определены то завершаем итерацию
  total += data[i];
}
console.log(total); // =>7 а иначе вернул бы NaN

// 5.5.4 return
// т.к функции это выражение (а return может встречаться только внутри функций), то в них return указывает значение выражения
// без него функция выполнила бы все операции и вернула undefined передав код дальше
// Может выполняться без выражения, если надо чтобы возвращала undefined:
function displayObject(o) {
  if (!o) return; // если аргумент null или undefined - выходим
  // Код функции
}

// 5.5.5 yield
// Используется в генераторных функциях, делает тоже самое что и break только без передачи управления (я так понял continue ток для генераторов)

// 5.5.6 throw (Исключение)
// Сигнал, который показывает что произошло какое то необычное событие. В системе когда такое происходит и это обнаруживает js он генерирует обьект Error c именем и messege к нему
// мы можем сами такое делать :
function factorial(x) {
  if (x < 0) throw new Error("Значение х не должно быть отрицательным"); // без throw ошибка не вызовется и выйдет, а так хоть скажет что не так
  let f;
  for (f = 1; x > 1; f *= x, x--); // пустое тело
  return f;
}
console.log(factorial(4));
//  В общем суть в том что когда throw вызывается, она ищет ближайший обработчик событий (catch) вверх по коду пока не найдет, если не нашло то вызывает ошибку

// 5.5.7 try/catch/finally
// Блок обработки исключений. В try - блок кода, чиь исключения д.б обработаны
// catch - блок операторов, вызываемый при возникновении исключений в блоке try
// catch(e) - локальная, блочная переменная для ссылки на обьект Error
// finally - блок, который гарантированно выполнится, вне зависимости от ошибок и исключений. с try д.б. хотя бы один (либо catch либо finally)
// выполняется при завершении блока try: 1) нормально, после достижения конца блока 2) из за оператора break, continue, return
// 3) из за исключение, обработанного catch 4) из за необработанного исключения, которое продолжило свое распространение
try {
  let n = Number(prompt("Введите положительное число", "")); // Запрашиваем число
  let f = factorial(n); // Вычисляем факториал
  alert(n + "! = " + f); //Выводим результат
} catch (ex) {
  alert(ex);
} // если что то не так - сообщаем
// Если в try  ошибка и в catch она есть- обрабатываем. Если нет, тогда сначала выполняем finally, после чего переходим к ближайшей внешней конструкции catch
// Если в finally генерируется исключение, то оно замещает любое незаконченное исключение... Крч если в finalle был
// return,break,continue,throw - то все отменяется и переходится к этим операторам
// Эмуляция for:
// while (проверка){
//   try {тело}
//   finally {инкрементирование}
// } Однако даже в таком случае, если в теле есть break то точная эмуляция невозможна (из за доп инкрементирования которое вызывается после break)
//Это все может быть выполнено тупо для того чтобы вместо ошибки возвратить undefined:
function parseJSON(s) {
  try {
    return JSON.parse(s);
  } catch {
    // что то не так, но нам срать что именно
    return undefined;
  }
}

// 5.6 Смешанные операторы
// 5.6.1 with
// выполняет блок кода так, как если бы свойства указанного обьекта были переменными (с вилимостью внутри блока)
// with (обьект) оператор. Крч в строгом использовать нельзя, в обычном не реккомендуется, опять же из за оптимизации
//нужен чтобы по 10 раз свойства не писать. Например если у нас HTML элемент находится по адресу document.forms[0].address.value то можем делать так:

// with (document.forms[0]) {
//   // Далее появляется возможность доступа к элементам:
//   name.value = ""; // а было бы: document.forms[0].name.value = ""
//   address.value = "";
//   email.value = "";
// }
// Но как бы можно было и так:
// let f=document.forms[0]
// f.name.value = "" // и т.д.

// 5.6.2 debugger - точка останова для отладочных целей
// 5.6.3 use strict - в начале директивы указывает, что внутри будет строгий код. (Без некоторых возможностей, но с большей безопасностью)

// 5.8 Резюме
// break - выходит из самого внутреннего цикла или switch либо из именованного включающего оператора
// case - помечает оператор внутри switch
// class - обьявляет класс
// const - обьявляет или инициализирует одну или более констант
// continue - Начинает слудеющюю итерацию самого внутреннего цикла или именованного цикла
// debugger Точка остановки отладчика
// do/while - Альтернатива while
// export - Обьявляет значения, которые могут быть импортированы другими модулями
// for -  цикл
// for/await - Асинхронно проходит по значениям асинхронного итератора
// for/in - Перечисляет имена свойств обьекта
// for/of - Перечисляет значения итерируемого обьекта, такого как массив
// function -обьявляет функцию
// if/else - Выполняет один или другой оператор в зависимости от условия
// import - Обьявляет имена для значений, обьявленных в других модулях
// метка - Назначает оператору имя, для использования с break и continue
// let - Обьявляет и инициализирует одну или более переменных с блочной областью видимости
// return - Возвращает значение функции
// switch - Реализует разветвления по множеству веток case или default
// throw - Генерирует исключение
// try/catch/finally - Обрабатывает исключения и обеспечивает код очистки
// 'use strict' - Применяет ограничения строго режима к сценарию или функции
// var - Обьявляет и инициализирует одну или более переменных с функциональной обл видимости (старый синтаксис)
// while - Базовая конструкция цикла
// with - Расширяет цепочку областей видимости (не рекомендуется к использованию и запрещен в строгом режиме)
// yield - Предоставляет значение, подлежащее итерации; Применяется только в генераторных функциях

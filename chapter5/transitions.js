// 5.5 Переходы
// 5.5.1 Помеченные операторы
// идентификатор: оператор
// В общем можно дать имя любому оператору, и затем вызывать его внутри тела
let token;
//* mainloop: while (token !== null) {
//   // что то делать
//   continue mainloop; // перейти к след итерации
//   // какой то код *
// }

// 5.5.2 break
// Если используется в одиночку, то немедленно выходит из внутреннего цикла или switch
// вообще нужен если нет необходимости продолжать цикл:
// for (let i = 0; i < a.length; i++) {
//   if ((a[i] = target)) break;
// }

// Если break используется вместе с меткой, то он завершит тот цикл, чей меткой является (!!! главное чтобы между именем и break не было перехода строки)

// Например надо посчитать  все числа в матрице (двумерном масстве)
// let matrix = getData(); // Берем откуда нить двумерный массив
let matrix = [[1], [2], [3]];
let sum = 0,
  success = false;

computeSum: if (matrix) {
  for (let x = 0; x < matrix.length; x++) {
    let row = matrix[x];
    if (!row) break computeSum;
    for (let y = 0; y < row.length; y++) {
      let cell = row[y];
      if (isNaN(cell)) break computeSum;
      sum += cell;
    }
  }
  success = true;
} // вот сюда выйдут операторы break
// Ну и соответственно если мы пришли сюда с success = false значит какая то фигня с матрицей
console.log(sum);
console.log(success);

// 5.3.3 continue
// синтаксис и метки аналогично break, только continue перезапускает цикл со СЛЕДУЮЩЕЙ итерацией (эта заканчивается)
// в разных видах выполняется по разному, но основное:
// в циклах for сначаа инкрементируется значение, а затем проиходит проверка и если все ок итерация
// а в циклах while сразу переходит к условию
let data = [1, 2, undefined, 4],
  total = 0;
for (let i = 0; i < data.length; i++) {
  if (!data[i]) continue; // Если данные не определены то завершаем итерацию
  total += data[i];
}
console.log(total); // =>7 а иначе вернул бы NaN

// 5.5.4 return
// т.к функции это выражение (а return может встречаться только внутри функций), то в них return указывает значение выражения
// без него функция выполнила бы все операции и вернула undefined передав код дальше
// Может выполняться без выражения, если надо чтобы возвращала undefined:
function displayObject(o) {
  if (!o) return; // если аргумент null или undefined - выходим
  // Код функции
}

// 5.5.5 yield
// Используется в генераторных функциях, делает тоже самое что и break только без передачи управления (я так понял continue ток для генераторов)

// 5.5.6 throw (Исключение)
// Сигнал, который показывает что произошло какое то необычное событие. В системе когда такое происходит и это обнаруживает js он генерирует обьект Error c именем и messege к нему
// мы можем сами такое делать :
function factorial(x) {
  if (x < 0) throw new Error("Значение х не должно быть отрицательным"); // без throw ошибка не вызовется и выйдет, а так хоть скажет что не так
  let f;
  for (
    f = 1;
    x > 1;
    f *= x, x-- // пустое тело
  );
  return f;
}
console.log(factorial(-4));

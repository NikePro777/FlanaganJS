// 8.1 Определение функций
// 8.1.1 Обьявления функций
// Обьявление состоит из ключевого слова function за которым следует идентификатор (имя функции), + (параматры функции) + {операторы и тело}
function printprops(o) {
  // Выводит имя и знач каждого параметра, возвращает undefined
  for (let p in o) {
    console.log(`${p}:${o[p]}\n`);
  }
}
function distance(x1, y1, x2, y2) {
  // вычисляет расстояние между точками в декартовых координатах
  let dx = x2 - x1;
  let dy = y2 - y1;
  return Math.sqrt(dx * dx + dy * dy);
}
function factorial(x) {
  // рекурсивная функция вычисляющая факториал
  if (x <= 1) return 1;
  return x * factorial(x - 1);
}
// 8.1.2 Выражения функций
const square = function (x) {
  return x * x;
};
const f = function fact(x) {
  // выражения функций могут включать имена, которые полезны для рекурсий
  if (x <= 1) return 1;
  else return x * fact(x - 1);
};
// Выражения функций могут использоваться как аргументы других функций:
[3, 2, 1].sort(function (a, b) {
  return a - b;
});
// выражения функций иногда определяются и немежденно вызываются:
let tensquared = (function (x) {
  return x * x;
})(10); // 100
console.log(tensquared);
// Обьявление функции на самом деле обьявляет переменную и присваивает ей обьект функции
// Есть разница между обьявлением функции и присваиванием функции переменной, после ее создания посредством выражения.
// После обьявления функцией можно пользоваться. (функция поднимается подобно var) а во втором случае функция обязательно должна быть вычеслена

// 8.1.3 Стрелочные функции
// нет названия и обьявления функции, поскольку такая запись это выражение а не оператор
const sum = (x, y) => {
  return x + y;
}; // Но можно еще короче: если тело, это оператор return, тогда можно все опустить ( и ретерн и {}):
const sum1 = (x, y) => x + y;
// А если стрелочная функция имеет один параметр, тогда и () можно опустить
const polynomial = (x) => x * x + 2 * x + 3;
// Тем не менее функция без параметров д.б записана в ()
const constantFact = () => 42;
// Ели мы возвращаем обьектный литерал {} то его надо поместить в круглые скобки во избежания синтаксической путаницы
const q = (x) => {
  return { value: x };
}; // правильно q возвращает обьект
const g = (x) => ({ value: x }); // правильно g возвращает обьект
const h = (x) => {
  value: x; // Хрень!! h ничего не возвращает!!
};
//  const i = x=> {x:v,w:x} - вообще синтаксическая ошибка
// Стрелочные функции идеальны когда нужно передать одну функцию в другую (методы map,reduce и др)
let filtered = [1, null, 2, 3].filter((x) => x !== null); // [1, 2, 3] создать копию массива не содержащую null
let squares = [1, 2, 3, 4].map((x) => x * x); // [1, 4, 9, 16]

// Стрелочные функции берут this из среды, в которой они определены. (а не определяют собственный контекст вызова как другие функции)
// Стрелочные функции не имеют прототипа... их нельзя применить в качестве конструкторов для новых классов

// 8.1.4 Вложенные функции
// в js функции могут быть вложены внутри других функций:
function hypotenuse(a, b) {
  function square(x) {
    return x * x;
  }
  return Math.sqrt(square(a) + square(b));
}
// важной особенностью является область видимости: внутренние функции могут читать и записывать параметры внешней функции (square прочитала a,b - параментры hypotenuse)

// 8.2 Вызов функций
printprops({ x: 1 });
let total = distance(0, 0, 2, 1) + distance(2, 1, 3, 5);
console.log(total);
let probability = factorial(5) / factorial(13);
console.log(probability);
// в вызове каждое выпажение (между ()) вычисляется, а результирующие выражения становятся аргументами функции
// Для обыкновенных вызовов функций, возвращаемое значение будет то, которое получилось после return или undefined, если return нет или в нем ничего не получилось

// Условный вызов
// можно вызвать функцию условно: (т.е. вызвать при условии что она вернет не null или undefined)
console.log(f?.(3)); // ~ эквивалентно
console.log(f !== null && f !== undefined ? f(3) : undefined);
// в нестрогом режимом контекстом функции (this) будет глобальный обьект, а вот в строгом undefined
// поэтому this можно использовать для определения, используется ли сейчас строгий режим
const strict = (function () {
  return !this;
})();
console.log(strict);

// 8.2.2 Вызов метода. Метод это функция, хранящаяся в свойстве обьекта
o = {};
o.m = f;
console.log(o.m);
// Вызов метода от вызова функции отличается важным аспектом - наличием контекста вызова. на него можно ссылаться с помощью this:
let calculator = {
  operand1: 1,
  operand2: 1,
  add() {
    this.result = this.operand1 + this.operand2;
  },
};
console.log(calculator.result); // в данном случае она не вычеслена
console.log(calculator.add()); // вычисляем
console.log(calculator.result); // 2
// Методы можно вызывать используя и [] :
o["m"](3, 2);

// Если вложенная функция вызывается как метод, то this будет относится к обьекту, на котором она вызывалась
// Если фкнкция вызывается как функция, то в нестрогом режиме контекстом будет глобальный обьект, а в строгом undefined
// Вложенная в метод функция, вызываемая как функция - НЕ получает контекста вызова
o = {
  m: function () {
    let self = this;
    this === o; // true
    console.log(self); // {o}
    // const f = function () {
    //   console.log(this === o); // true
    // }.bind(this);
    f();
    function f() {
      console.log(this === o); // false // т.е. внутри вложенной функции this это глобальный обьект
      console.log(self === o); // true // self является внешним значением this
      console.log(self); // {o}
    }
  },
};
console.log(o.m()); // undefined
console.log(self); // window
// Стрелочный функции наследуют this, поэтому можно сделать так:
// const f = () => {
//   this === o; //true
// };
// ИЛИ Нужно было поменять строчки местами (поместив метод перед вызовом)
//  function f() {
// f();

// Другой способо это вызов bind() вложенной функции с целью определения новой функции которая будет неявно вызвана:
// const f = function () {
//   this === o;
// }.bind(this);

// 8.2.3 Вызов конструктора
// Если перед вызовом функции писать new то будет вызван конструктор. Если в него передать  аргументы то они будут вычислены и переданы как обычной функции
// Конструкторы отличаются от функций контекстом и методом обработки аргументов
o = new Object();
o = new Object(); // Эквивалентны!
// Вызов консруктора создает новый пустой обьект, который унаследован от обьекта, заданным prototype конструктора
// this становится контекстом конструктора! т.е. new o.m() o-не применяется в качестве конструктора вызова

// 8.2.4 Косвенный вызов функции
// Функции в js  это обьекты, а обьекты имеют методы. Поэтому любая функция тоже имеет методы. apply() и call() вызывают функцию косвенно
// оба метода позволяют указать this для вызова. т.е. мы можем вызвать любую функцию как метод определенного обьекта, даже если у этого обьекта нет этой функции
// call() в качестве аргументов функции исользует собственный список аргументов а apply ожидает массив значений, которые применяются как аргументы

// 8.3 Аргументы функций
// 8.3.1 Необязательные параметры и стандартные значения
// Если функция принимает меньше параметров чем необходимо, то недостающие заменяются на стандартные (чаще всего undefined)
// лучше писать функции, чтобы аргументы были необязательны:
function getPropertyNames(o, a) {
  a = a || [];
  // if (a === undefined) a = []; // Если а не передали, то создаем пустой массив, куда будем все складывать
  for (let property in o) a.push(property);
  return a;
}

// getPropertyNames() может вызываться с 1 или 2  аргументами:
(o = { x: 1 }), (p = { y: 2, z: 3 });
a = getPropertyNames(o);
console.log(a); // ['x'] - создался пустой массив и туда закинулись свойства обьекта о
getPropertyNames(p, a);
console.log(a); // ['x', 'y', 'z'] - теперь параметр а передали, поэтому к его свойствам все и добавилось
// в ES6 можно задавать стандартные параметры прямо в функции, ждя этого достаточно поставить равно, и он будет использоваться, если аргумент не передадут:
function getPropertyNames2(o, a = []) {
  for (let property in o) a.push(property);
  return a;
}
// Значение предыдущего параметра можно применять при определении стандартных значений которые последуют за ним:

const rectangle = (width, heigth = width * 2) => ({ width, heigth });
console.log(rectangle(1)); // {width: 1, heigth: 2}

// 8.3.2 параметры остатка и списки аргументов переменной длины ( функции когда передали аргументов больше чем ожидали)
function max(first = -Infinity, ...rest) {
  let maxValue = first; // Начинаем с предположения что первый аргумент самый большой, затем проходимся в цикле,в поисках наибольшего
  for (let n of rest) {
    if (n > maxValue) {
      maxValue = n;
    }
  }
  return maxValue;
}
console.log(max(1, 10, 100, 2, 3, 1000, 4, 5, 6)); // 1000
// причем если мы передадим только 1 параметр(или вообще не передадим) то остаток (rest) будет =[] причем он в любом случае будет массивом. Соответственно для него нет смысла определять стандартное значение - оно равно []
// такие функции называеются функции с переменным числом параматров, с переменной арностью или vararg-функциями

// Обьект arguments
// до ES6 параметры остатка записывались в arguments - обьект похожий на массив, который позволяет вытаскивать аргументы по номеру а не по имени:

function max(x) {
  let maxValue = -Infinity;
  for (let i = 0; i < arguments.length; i++) {
    if (arguments[i] > maxValue) maxValue = arguments[i];
  }
  return maxValue;
}
console.log(max(1, 10, 100, 2, 3, 1000, 4, 5, 6)); // 1000
// не оптимизируется, поэтому лучше не использовать (в строгом режиме такое слово зарезервировано, поэтому все плохо)

// 8.3.4 Операция распространения для вызова функций
// Операция распространения ... складывает все элементы в массив значений:
let numbers = [5, 2, 1, -1, 100, 34];
console.log(Math.min(...numbers)); //-1
//  в аргументах функции же ... собирает все "лишние" аргументы в массив

// Эта функция принимает функцию и возвращает версию в виде оболочки
function timed(f) {
  return function (...args) {
    // Собираем все аргументы в массив args
    console.log(`Вход в функцию ${f.name}`);
    let startTime = Date.now();
    try {
      // Распространяем все аргументы в функцию-оболочку
      return f(...args); // Spread the args back out again
    } finally {
      // Перед возвратом возвращаемого значения выводим затраченное время
      console.log(`Выход из ${f.name} спустя ${Date.now() - startTime}ms`);
    }
  };
}

// Рассчитать сумму чисел между 1 и n методом грубой силы
function benchmark(n) {
  let sum = 0;
  for (let i = 1; i <= n; i++) sum += i;
  return sum;
}

// Вызываем хронометрическую версию тестовой функции
timed(benchmark)(1000000); // => 500000500000; this is the sum of the numbers

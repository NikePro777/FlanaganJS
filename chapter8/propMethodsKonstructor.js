// 8.7 Свойства, методы и конструкторы функций
// 8.7.1 length - указывает арность функции ( количество аргументов)
// 8.7.2 name - имя функции)
// 8.7.3 prototype - когда функция создается с помощью конструктора, вновь созданный обьект наследует все свойства прототипа

// 8.7.4 Метода call() и apply()
// Позволяют вызывать функцию, как если бы она была методом другого обьекта. Аргумент - обьект на котором должна вызываться функция, он же контекст он же this
// дальнейшие аргументы - значения, которые передаются вызываемой функции. У apply аналогично, только эти значения передаются в виде массива a.apply(o,[1,2])
// Заменяет метод имени м обьекта о версией, которая записывает в журнал сообщения до и после вызова исходного метода
function trace(o, m) {
  let original = o[m]; // Запомнить исходный метод в замыкании
  o[m] = function (...args) {
    // Определяем новый метод
    console.log(new Date(), "Entering:", m); // Записать сообщение
    let result = original.apply(this, args); // вызвать исходный метод
    console.log(new Date(), "Exiting:", m); // Записать сообщение
    return result; // Return result.
  };
}

// 8.7.5 Метод bind()
// основная цель - привязка функции к обьекту. в результате вызова на функции f и передача обьекта о возвращается новая функция. Вызов новой функции
// приводит к вызову f как методу о. Любые аргументы, передаваемые новой функции - передаются исходной
let x = 1;
function f1(y) {
  console.log(this);
  return this.x + y;
} // Этой функции необходима привязка
let o = { x: 1 }; // Обьект, к которому будет осуществлена привязка
let g = f1.bind(o); // вызов g приводит к вызову f1 на о
console.log(g(2)); //3
let p = { x: 10, g }; // Вызов g() как метода обьекта this
console.log(p.g(2)); // 3 g по прежнему привязан к о, а не к p

// Стрелочные функции наследуют значение this от среды, в которой определяются, и не могут быть переопределены bind
// но bind обеспечивает так же частиное применение - любые аргументы после первого передаются наравне с this. Частичное применение - каррирование
let sum = (x, y) => x + y;
let succ = sum.bind(null, 1); // привязывает первый аргумент к 1, т.е. x=1 теперь
console.log(succ(2)); // 3 х=1 (привязали выше) а для у мы передаи 2

function f(y, z) {
  return this.x + y + z;
}
g = f.bind({ x: 1 }, 2); // привязали this и y
console.log(g(3)); // 6 т.к. this.x=1 , y=2
